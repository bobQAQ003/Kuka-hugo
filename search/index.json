[{"content":"引入PJAX 从 MoOx/pjax（不带JQuery）这里引入 我们需要刷新的是左侧边栏 ，右侧边栏 和中间的内容 从源代码可以发现这些元素都被一个\u0026lt;div class=\u0026quot;main-container\u0026quot;\u0026gt;...\u0026lt;/div\u0026gt;包裹着 根据官方文档，在layouts/partials/footer/custom.html加入以下代码来引入PJAX： 1\u0026lt;!-- 【custom.html】 --\u0026gt; 2\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/pjax/pjax.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 3\u0026lt;script\u0026gt; 4 var pjax = new Pjax({ 5 selectors: [ 6 \u0026#34;.main-container\u0026#34; 7 ] 8 }) 9\u0026lt;/script\u0026gt; 我这里先创建layouts/partials/footer/pjax.html，再在custom.html里引用 1\u0026lt;!-- pjax.html --\u0026gt; 2\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/pjax/pjax.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 3\u0026lt;script\u0026gt; 4 var pjax = new Pjax({ 5 selectors: [ 6 \u0026#34;.main-container\u0026#34;, 7 ] 8 }) 9\u0026lt;/script\u0026gt; 10 11\u0026lt;!-- custom.html --\u0026gt; 12{{partial \u0026#34;footer/pjax.html\u0026#34;}} 文章样式修复 问题描述： 引入pjax后，重启hugo server -D，发现文章样式丢失，手动点击刷新可以恢复 产生原因： \u0026lt;body\u0026gt;标签中的class名缺失article-page，导致文章样式丢失 解决思路： 通过官方提供了数据预处理方法，来预处理数据，获取到新页面的className，然后我们手动将这className设置到\u0026lt;body\u0026gt;上 具体步骤： 修改layouts/partials/footer/pjax.html，（如果是在custom.html加了pjax就在那里改）引入以下代码： 1\u0026lt;script\u0026gt; 2 pjax._handleResponse = pjax.handleResponse; 3 pjax.handleResponse = function(responseText, request, href, options) { 4 if (request.responseText.match(\u0026#34;\u0026lt;html\u0026#34;)) { 5 if (responseText) { 6 // 将新页面的html字符串解析成DOM对象 7 let newDom = new DOMParser().parseFromString(responseText, \u0026#39;text/html\u0026#39;); 8 // 获取新页面中body的className，并设置回当前页面 9 let bodyClass = newDom.body.className; 10 document.body.setAttribute(\u0026#34;class\u0026#34;, bodyClass) 11 } 12 // 放行，交给pjax自己处理 13 pjax._handleResponse(responseText, request, href, options); 14 } else { 15 // handle non-HTML response here 16 } 17 } 18\u0026lt;/script\u0026gt; 主题切换修复 问题描述： 切换页面后，左下角切换主题颜色按钮不生效 产生原因： 在Stack主题源码assets/ts/colorScheme.ts中，脚本初始化时，会给元素绑定一个点击事件。但因为页面切换了，替换了该元素，但该元素没有重新绑定点击事件，导致点击主题切换失效 解决思路：\n在PJAX切换完页面后，重新执行一遍colorScheme.ts的初始化，使元素重新绑定点击事件 而colorScheme.ts被main.ts引用，在main.ts中执行了初始化，并且main.ts生成了全局变量 Stack 所以在PJAX执行完后，使用全局变量 Stack ，执行里面的初始化方法，重新执行一遍脚本，来绑定点击事件 PJAX官方文档也提供了PJAX执行完后的事件pjax:complete，监听这个事件，Stack 执行初始化就好 具体步骤：\n修改layouts/partials/footer/pjax.html，引入以下代码 1\u0026lt;script\u0026gt; 2 document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { 3 // Stack脚本初始化 4 window.Stack.init(); 5 }) 6\u0026lt;/script\u0026gt; 文章搜索修复 问题描述： 使用文章搜索功能时，输入关键词，无任何搜索记录 产生原因： 查看assets/ts/search.tsx文件，情况和上面的colorScheme.ts类似，存在绑定事件 解决思路： 把 search.tsx 初始化内容封装为一个函数，并把函数 export 出来 由 main.ts 引入这个函数，并放到 Stack.init() 的方法中，利用此方法来重新初始化搜索脚本 具体步骤： 修改assets/ts/search.tsx代码，封装方法并export 1/** 2 * 把window.addEventListener(\u0026#39;load\u0026#39; ...这部分代码注释掉 3 * 初始化工作交给Stack.init()处理了，不需要这个了 4 */ 5... 6function searchInit() { 7 let search = document.querySelector(\u0026#39;.search-result\u0026#39;); 8 if (search) { 9 const searchForm = document.querySelector(\u0026#39;.search-form\u0026#39;) as HTMLFormElement, 10 searchInput = searchForm.querySelector(\u0026#39;input\u0026#39;) as HTMLInputElement, 11 searchResultList = document.querySelector(\u0026#39;.search-result--list\u0026#39;) as HTMLDivElement, 12 searchResultTitle = document.querySelector(\u0026#39;.search-result--title\u0026#39;) as HTMLHeadingElement; 13 14 new Search({ 15 form: searchForm, 16 input: searchInput, 17 list: searchResultList, 18 resultTitle: searchResultTitle, 19 resultTitleTemplate: window.searchResultTitleTemplate 20 }); 21 } 22} 23 24export { 25 searchInit 26} 修改assets/ts/main.ts，引入搜索初始化方法并调用 1... 2import { searchInit } from \u0026#34;ts/search\u0026#34;; 3let Stack = { 4 init: () =\u0026gt; { 5 ... 6 // 调用search脚本初始化方法 7 searchInit(); 8 } 9} 从Stack模板文件复制layouts\\partials\\footer\\components\\script.html，把\u0026quot;JSXFactory\u0026quot; \u0026quot;createElement\u0026quot;补充，改法参考layouts\\page\\search.html， 搜索内容跳转修复 问题描述：\n能进行搜索，但搜索出来的内容并没有被PJAX识别到，导致PJAX没有拦截，进而导致页面刷新 产生原因：\n阅读 search.tsx 源码可知，搜索内容的数据，是通过 React.render() 动态渲染回页面的，这些动态数据没有被PJAX识别到 解决思路： PJAX官方文档提供给了重新解析数据的方法，所以在 React.render() 之后，调用PJAX方法，重新解析页面即可 具体步骤： 修改assets/ts/search.tsx，在动态渲染数据方法末尾让pjax重新解析文档 1private async doSearch(keywords: string[]) { 2 ... 3 /* 4 方法末尾，让pjax重新解析文档数据，识别动态渲染的数据 5 虽然当前文件没有pjax对象，但最后静态页面会生成一个整体的js文件 6 pjax对象那时就能识别到，就可成功调用 7 */ 8 pjax.refresh(document); 9} KaTeX修复 KaTex渲染失效 问题描述： 含有 数学公式(KaTeX) 的文章，里面的数学公式不能正常渲染出来 产生原因： 阅读源码layouts/partials/article/components/math.html，KaTeX渲染公式需要执行renderMathInElement，而PJAX的无刷新技术无法触发DOMContentLoaded的监听 解决思路： 将renderMathInElement封装为函数，交由PJAX加载结束后执行 具体操作： 修改layouts/partials/article/components/math.html，添加一个元素标签，便于判断文档是否使用了KaTeX 1... 2\u0026lt;div class=\u0026#34;math-katex\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; layouts/partials/footer/pjax.html，引入以下代码 1\u0026lt;script\u0026gt; 2 async function renderKaTeX() { 3 // 判断当前页面是否有KateX 4 let katex = document.querySelector(\u0026#34;.math-katex\u0026#34;); 5 if (!katex) { 6 return; 7 } 8 // 等待函数加载成功后，再执行渲染方法 9 while (typeof renderMathInElement !== \u0026#39;function\u0026#39;) { 10 await delay(500); 11 } 12 // KaTeX渲染方法 13 renderMathInElement(document.body, { 14 delimiters: [ 15 { left: \u0026#34;$$\u0026#34;, right: \u0026#34;$$\u0026#34;, display: true }, 16 { left: \u0026#34;$\u0026#34;, right: \u0026#34;$\u0026#34;, display: false }, 17 { left: \u0026#34;\\\\(\u0026#34;, right: \u0026#34;\\\\)\u0026#34;, display: false }, 18 { left: \u0026#34;\\\\[\u0026#34;, right: \u0026#34;\\\\]\u0026#34;, display: true } 19 ], 20 ignoredClasses: [\u0026#34;gist\u0026#34;] 21 }); 22 } 23 24 /** 25 * 同步延迟 26 */ 27 function delay(time) { 28 return new Promise(resolve =\u0026gt; { 29 setTimeout(resolve, time) 30 }) 31 } 32 33 document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { 34 renderKaTeX(); 35 }) 36\u0026lt;/script\u0026gt; 引用块和公式块冲突 问题描述：\n在引用块中又写了公式块，最终渲染出这样： 产生原因：\nTypora 内置的 Markdown 解析器 先合并 blockquote 行、再交给 MathJax，所以Typora显示正常 而 Hugo（Goldmark 解析器）逐行解析，每一行前面都带着 \u0026gt;，于是 Goldmark 把 \u0026gt; 转义成 \u0026gt; 塞进公式节点，KaTeX 收到的是：\u0026gt; \\mu(z_t) = 0.8 \\quad (...) 解决思路：\n目前没有很好的解决方法，只能是避免混用 浏览量统计失效 问题描述： 先前使用的vercount在引入Pjax后失效，必须手动刷新才会生效 产生原因： 原始的Vercount脚本在页面第一次加载时执行，它会在页面中插入浏览量显示的元素。但是当使用Pjax加载x新页面时，脚本不会自动重新执行，因此新页面中的浏览量元素没有被插入。 解决思路： 动态重新加载脚本，移除旧脚本，清除之前的执行状态， 创建新脚本，等待 pjax:complete 完成后再添加到 DOM 中 具体步骤： layouts/partials/footer/pjax.html，引入代码 1\u0026lt;script\u0026gt; 2 // 浏览量统计 3 function initVerCount() { 4 // 移除已存在的 Vercount 脚本 5 const existingScript = document.querySelector(\u0026#39;script[src=\u0026#34;https://cn.vercount.one/js\u0026#34;]\u0026#39;); 6 if (existingScript) { 7 existingScript.remove(); 8 } 9 10 // 创建新的 Vercount 脚本 11 const newScript = document.createElement(\u0026#39;script\u0026#39;); 12 newScript.src = \u0026#39;https://cn.vercount.one/js\u0026#39;; 13 newScript.defer = true; 14 15 // 添加到 head 中 16 document.head.appendChild(newScript); 17 } 18 19 document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { 20 ... 21 initVerCount(); 22 }) 23\u0026lt;/script\u0026gt; 网站标题更改 问题描述： 使用了PJAX后，点击左侧边栏和文章，网站标题都是你在.yaml中设置的languages.zh-cn.title，当你手动刷新才会变成相关页面 产生原因： PJAX 通过 AJAX 加载新页面的内容（这里配置的 selectors: [\u0026quot;.main-container\u0026quot;]，只替换主容器），而不进行完整的页面重载（full page reload）。这意味着title部分没有进行更新。 解决思路： 在 handleResponse 函数中添加逻辑：从新页面的 HTML 响应中提取 \u0026lt;title\u0026gt;标签，设置到document.title 具体步骤： 在\\layouts\\partials\\footer\\pjax.html中修改文章格式的同时，添加title 1\u0026lt;script\u0026gt; 2 // pjax刷新区域 3 var pjax = new Pjax({ 4 selectors: [ 5 \u0026#34;.main-container\u0026#34;, 6 ] 7 }) 8 9 // 修正文章样式丢失 10 pjax._handleResponse = pjax.handleResponse; 11 pjax.handleResponse = function(responseText, request, href, options) { 12 if (request.responseText.match(\u0026#34;\u0026lt;html\u0026#34;)) { 13 // 将新页面的html字符串解析成DOM对象 14 let newDom = new DOMParser().parseFromString(responseText, \u0026#39;text/html\u0026#39;); 15 16 // 1. 更新 body class，获取新页面中body的className，并设置回当前页面 17 let bodyClass = newDom.body.className; 18 document.body.setAttribute(\u0026#34;class\u0026#34;, bodyClass) 19 20 // 2. 更新 \u0026lt;title\u0026gt; 21 let newTitle = newDom.querySelector(\u0026#39;title\u0026#39;); 22 if (newTitle \u0026amp;\u0026amp; newTitle.textContent) { 23 document.title = newTitle.textContent.trim(); 24 } 25 26 pjax._handleResponse(responseText, request, href, options); 27 } else { 28 // handle non-HTML response here 29 } 30 } 31... 32\u0026lt;/script\u0026gt; 进度条加载 问题描述： 使用了PJAX后，原先采用的进度条失效，采用另外的方法 具体步骤： 前往【topbar】下载zip包，将解压后的 topbar.min.js 放到assets\\js\\topbar.min.js 通过监听PJAX两个事件 pjax:send 和 pjax:complete 实现伪进度条 layouts/partials/footer/pjax.html，引入代码 1{{ with resources.Get \u0026#34;js/topbar.min.js\u0026#34; }} 2 \u0026lt;!-- 引入本地JS脚本 --\u0026gt; 3 \u0026lt;script src={{ .Permalink }}\u0026gt;\u0026lt;/script\u0026gt; 4{{ end }} 5\u0026lt;script\u0026gt; 6 // 修改进度条颜色 7 topbar.config({ 8 barColors: { 9 \u0026#39;0\u0026#39;: \u0026#39;rgba(255, 255, 255, 1)\u0026#39;, // 进度0%白色 10 \u0026#39;1.0\u0026#39;: \u0026#39;rgba(0, 149, 234, 1)\u0026#39; // 进度100%蓝色 11 } 12 }) 13\t14 document.addEventListener(\u0026#39;pjax:send\u0026#39;, () =\u0026gt; { 15 // 显示顶部进度条 16 topbar.show(); 17 }) 18\t19 document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { 20 .... 21 // 隐藏顶部进度条 22 topbar.hide(); 23 }) 24\u0026lt;/script\u0026gt; ","date":"2025-10-25T09:40:08+08:00","permalink":"https://bobqaq003.github.io/Kuka-hugo/p/hugo%E7%BE%8E%E5%8C%96%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","title":"【Hugo】美化过程中遇到的问题"},{"content":" 为避免踩坑，凡是需要更改的文件都从themes/主题复制到主目录下，个性化配置文件建议都在博客主目录下操作，减少更新主题时个性化配置被覆盖的麻烦。\n每次服务启动，会同步更新所有位置配置文件，但主目录配置文件优先级最高\nyaml配置 添加行号后复制代码会带有行号 参考 小白hugo博客装修笔记（2）- B1ain’s Blog\n手动复制有行号 在/assets/scss/custom.scss 文件中添加如下内容，将行号设定为不可选中\n1// 手动复制禁止复制行号 2.highlight .ln { 3 user-select: none; 4} copy按钮复制带行号 修改/themes/hugo-theme-stack/assets/ts/main.ts文件中的复制按钮逻辑。\n但具体情况是，在本地进行调试时，确实手动复制和copy复制都会涉及行号。当部署到github pages打开后，copy不会有影响，反而手动复制可能会复制到行号。\n所以具体情况看个人博客部署情况吧。反正能用，若要修改参考 Hugo-stackの美化\n具体修改assets/ts/main.ts\n1highlights.forEach(highlight =\u0026gt; { 2 const copyButton = document.createElement(\u0026#39;button\u0026#39;); 3 copyButton.innerHTML = copyText; 4 copyButton.classList.add(\u0026#39;copyCodeButton\u0026#39;); 5 highlight.appendChild(copyButton); 6 7 const codeBlock = highlight.querySelector(\u0026#39;code[data-lang]\u0026#39;); 8 if (!codeBlock) return; 9 10 copyButton.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { 11 // 创建一个临时容器来克隆代码块的内容 12 const tempCodeBlock = codeBlock.cloneNode(true) as HTMLElement; 13 14 // 删除行号，行号的元素是 \u0026lt;span class=\u0026#34;ln\u0026#34;\u0026gt; 15 const lineNumbers = tempCodeBlock.querySelectorAll(\u0026#39;.ln\u0026#39;); 16 lineNumbers.forEach(lineNumber =\u0026gt; lineNumber.remove()); 17 18 // 获取没有行号的纯文本内容 19 const codeText = tempCodeBlock.textContent; 20 21 navigator.clipboard.writeText(codeText || \u0026#39;\u0026#39;) 22 // navigator.clipboard.writeText(codeBlock.textContent) 23 .then(() =\u0026gt; { 24 copyButton.textContent = copiedText; 25 26 setTimeout(() =\u0026gt; { 27 copyButton.textContent = copyText; 28 }, 1000); 29 }) 30 .catch(err =\u0026gt; { 31 alert(err) 32 console.log(\u0026#39;Something went wrong\u0026#39;, err); 33 }); 34 }); 35}); 左边栏副标题换行 参考 Hugo-stackの美化 II\n找到 layouts/partials/sidebar/left.html，复制到博客的同名主文件夹下：\n1\u0026lt;div class=\u0026#34;site-meta\u0026#34;\u0026gt; 2 \u0026lt;h1 class=\u0026#34;site-name\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;{{ .Site.BaseURL | relLangURL }}\u0026#34;\u0026gt;{{ .Site.Title }}\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; 3 \u0026lt;h2 class=\u0026#34;site-description\u0026#34;\u0026gt;{{ .Site.Params.sidebar.subtitle }}\u0026lt;/h2\u0026gt; 4 \u0026lt;h2 class=\u0026#34;site-description\u0026#34;\u0026gt;{{ .Site.Params.sidebar.subtitle | safeHTML }}\u0026lt;/h2\u0026gt; 5\u0026lt;/div\u0026gt; 当然也可以修改stack模板下hugo-theme-stack里的文件，但不建议，毕竟还要通过源码进行学习。\n然后在 hugo.yaml 中在要换行的地方加上 \u0026lt;br\u0026gt;：\n1languages: 2 en: 3 languageName: English 4 title: Example Site 5 weight: 1 6 params: 7 sidebar: 8 subtitle: Example description 9 zh-cn: 10 languageName: 中文 11 title: KukaDam 12 weight: 2 13 params: 14 sidebar: 15 subtitle: \u0026#34;晚来天欲雪\u0026lt;br\u0026gt;能饮一杯无\u0026#34; Markdown样式 键盘样式 参考 Hugo Stack 魔改美化 | Naive Koala\n在 /assets/scss/custom.scss 中加入以下代码：\n1// 键盘样式 2kbd { 3 margin: 0 .1em; 4 padding: .1em .6em; 5 font-size: .8em; 6 color: #242729; 7 background: #fff; 8 border: 1px solid #adb3b9; 9 border-radius: 3px; 10 box-shadow: 0px 1px 0 rgba(12, 13, 14, 0.2), 0 0 0 2px #fff inset; 11 white-space: nowrap; 12 vertical-align: middle; 13 font-family: monospace; 14} 这样就可以呈现如下 Markdown 中的键盘样式： \u0026lt;kbd\u0026gt;CTRL\u0026lt;/kbd\u0026gt; + \u0026lt;kbd\u0026gt;C\u0026lt;/kbd\u0026gt;\nCTRL + C\n图床链接图片居中 目前 Stack 默认只支持本地引用的图片居中，而在使用 url 图片链接时没有居中格式。在 /assets/scss/partials/layout/article.scss Line 256 处（同级任意位置）增加以下代码：\n1// Center image from url source 2p \u0026gt; img { 3 display: block; 4 margin: 0 auto; 5 max-width: 100%; 6 height: auto; 7} 当启用fancybox时，上面的方法对fancybox不起作用，可以再上面代码的下方添加：\n1.post-img-view { 2 text-align: center; 3 4 a { 5 display: inline-block; 6 text-decoration: none; 7 border: none; 8 box-shadow: none; 9 10 img { 11 cursor: zoom-in; // 鼠标显示放大镜图标 12 transition: transform 0.3s ease; // 添加缩放动画效果 13 14 \u0026amp;:hover { 15 transform: scale(1.02); // 悬停时轻微放大 16 } 17 } 18 } 19} 图片放大 修改stack主题的配置文件： hugo.yaml，在params中添加： 1params: 2 fancybox: true 在/layouts/_default/_markup/render-image.html合适位置补充： 1{{if .Page.Site.Params.fancybox }} 2\u0026lt;div class=\u0026#34;post-img-view\u0026#34;\u0026gt; 3\u0026lt;a data-fancybox=\u0026#34;gallery\u0026#34; href=\u0026#34;{{ .Destination | safeURL }}\u0026#34;\u0026gt; 4\u0026lt;img src=\u0026#34;{{ .Destination | safeURL }}\u0026#34; alt=\u0026#34;{{ .Text }}\u0026#34; {{ with .Title}} title=\u0026#34;{{ . }}\u0026#34;{{ end }} /\u0026gt; 5\u0026lt;/a\u0026gt; 6\u0026lt;/div\u0026gt; 7{{ end }} 记得把原来的代码注释，否则会渲染两张图\n1\u0026lt;!-- \u0026lt;img src=\u0026#34;{{ $Permalink }}\u0026#34; 2\t{{ with $Width }}width=\u0026#34;{{ . }}\u0026#34;{{ end }} 3\t{{ with $Height }}height=\u0026#34;{{ . }}\u0026#34;{{ end }} 4\t{{ with $Srcset }}srcset=\u0026#34;{{ . }}\u0026#34;{{ end }} 5\tloading=\u0026#34;lazy\u0026#34; 6\t{{ with $alt }} 7\talt=\u0026#34;{{ . }}\u0026#34; 8\t{{ end }} 9\t{{ if $galleryImage }} 10\tclass=\u0026#34;gallery-image\u0026#34; 11\tdata-flex-grow=\u0026#34;{{ div (mul $image.Width 100) $image.Height }}\u0026#34; 12\tdata-flex-basis=\u0026#34;{{ div (mul $image.Width 240) $image.Height }}px\u0026#34; 13\t{{ end }} 14\u0026gt; --\u0026gt; 同理，在 layouts\\partials\\article\\components\\footer.html 中添加： 1{{if .Page.Site.Params.fancybox }} 2\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 3\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css\u0026#34; /\u0026gt; 4\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 5{{ end }} 字体修改 去字体网站，比如【100font】，下载自己想要的字体文件 .ttf\n把字体文件放到放入assets/font下（没有自己建）\n将以下代码修改并复制到layouts/partials/footer/custom.html文件中\n字体名：给字体命名一个别名，随便填写就好，保持统一就行 字体文件名：字体文件的全名，带后缀名的，也就是 xxx.ttf 1\u0026lt;style\u0026gt; 2 @font-face { 3 /* 提高自定义字体加载速度 */ 4 unicode-range: U+4E00-9FFF,U+0025-00F0,U+3040-30FF,U+1100-11FF,U+3130-318F,U+AC00-D7FF; 5 font-family: \u0026#39;字体名\u0026#39;; 6 src: url({{ (resources.Get \u0026#34;font/字体文件名\u0026#34;).Permalink }}) format(\u0026#39;truetype\u0026#39;); 7 } 8 9 :root { 10 --base-font-family: \u0026#39;字体名\u0026#39;; 11 --code-font-family: \u0026#39;字体名\u0026#39;; 12 } 13\u0026lt;/style\u0026gt; 测试：l，L，i，I （这几个字母字体用不好分不清）\n固定代码块高度 把以下内容添加到 assets/scss/partials/article.scss ：\n1.article-content { // 大概 line 205 2 .highlight { // line 331 3 background-color: var(--pre-background-color); 4 padding: var(--card-padding); 5 position: relative; 6 ... 7 // 修改 8 pre { // 可以注释之前的 9 margin: initial; 10 padding: 0; 11 margin: 0; 12 width: auto; 13 max-height: 30em; 14 scrollbar-width: none; /* Firefox */ 15 \u0026amp;::-webkit-scrollbar { 16 display: auto; 17 /* Chrome Safari */ 18 } 19 } 20 } 21} 固定高度后，还要去.yaml文件中修改参数，否则行号和代码块的滚动不一致\n1markup: 2 highlight: 3 lineNos: true 4 lineNumbersInTable: true 5 # lineNumbersInTable：使用表来格式化行号和代码, 而不是标签。这个属性一般设置为 true. 6 # lineNos：是否使用行号 设置lineNumbersInTable: false后，一般手动复制代码块和copy键复制都会把行号复制上，具体的修改看第一节\n组件 顶部返回按钮 参考Stack 主题的自定义 | L1nSn0w’s Log\n个人不是很喜欢返回键把左边菜单隐藏，给自己留个档。\n加载进度条 在layouts/partials/footer/custom.html加入代码：\n1\u0026lt;!-- 加载进度条 --\u0026gt; 2\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/zhixuan2333/gh-blog@v0.1.0/js/nprogress.min.js\u0026#34; integrity=\u0026#34;sha384-bHDlAEUFxsRI7JfULv3DTpL2IXbbgn4JHQJibgo5iiXSK6Iu8muwqHANhun74Cqg\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 3\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/gh/zhixuan2333/gh-blog@v0.1.0/css/nprogress.css\u0026#34; integrity=\u0026#34;sha384-KJyhr2syt5+4M9Pz5dipCvTrtvOmLk/olWVdfhAp858UCa64Ia5GFpTN7+G4BWpE\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; /\u0026gt; 4\u0026lt;script\u0026gt; 5 NProgress.start(); 6 document.addEventListener(\u0026#34;readystatechange\u0026#34;, () =\u0026gt; { 7 if (document.readyState === \u0026#34;interactive\u0026#34;) NProgress.inc(0.8); 8 if (document.readyState === \u0026#34;complete\u0026#34;) NProgress.done(); 9 }); 10\u0026lt;/script\u0026gt; 但这个方法可能在引入pjax后会失效，需要查看pjax文档进行监听\n樱花背景 下载地址【sakura.js】(CTRL + C 保存)，并放到assets/background文件夹下\n在layouts/partials/footer/custom.html加入代码：\n1\u0026lt;!-- 樱花背景 --\u0026gt; 2\u0026lt;script src={{ (resources.Get \u0026#34;background/sakura.js\u0026#34;).Permalink }}\u0026gt;\u0026lt;/script\u0026gt; 文章最后修改时间 在hugo.yaml加入代码：\n1frontmatter: 2 # 按优先级排序： 3 # :git - 文件提交修改时间 4 # lastmod - 文章里 lastmod 字段 5 # :fileModTime - 文件修改时间 6 # :default - 默认时间 7 lastmod: [\u0026#34;:git\u0026#34;, \u0026#34;lastmod\u0026#34;, \u0026#34;:fileModTime\u0026#34;, \u0026#34;:default\u0026#34;] 8 9enableGitInfo: true 10gitRepo: \u0026#34;https://github.com/your_username/your_username.github.io\u0026#34; 这个方法比较简单，但是时间会出现在文章末尾：\n更新时间的格式去 hugo.yaml 中的 params.dateFormat.lastUpdated 进行修改：\n1dateFormat: 2 published: 2006-01-02 3 lastUpdated: 2006-01-02 留档：文章开头显示更新时间，参考【Hugo】Stack主题自定义修改\n页面浏览量 这里用的是vercount\n修改layouts/partials/footer/custom.html，引入脚本：\n1\u0026lt;script defer src=\u0026#34;https://cn.vercount.one/js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 修改layouts/partials/article/components/footer.html，（没有文件夹可以从模板中复制）在合适的位置下加入代码：\n1\u0026lt;footer class=\u0026#34;article-footer\u0026#34;\u0026gt; 2 {{ partial \u0026#34;article/components/tags\u0026#34; . }} 3 4 {{ if and (.Site.Params.article.license.enabled) (not (eq .Params.license false)) }} 5 \u0026lt;section class=\u0026#34;article-copyright\u0026#34;\u0026gt; 6\t... 7 \u0026lt;/section\u0026gt; 8 {{ end }} 9 10 {{- if ne .Lastmod .Date -}} 11 \u0026lt;section class=\u0026#34;article-lastmod\u0026#34;\u0026gt; 12\t... 13 \u0026lt;/section\u0026gt; 14 {{- end -}} 15 \u0026lt;section\u0026gt; 16 页面浏览量\u0026lt;span id=\u0026#34;vercount_value_page_pv\u0026#34;\u0026gt;loading... \u0026lt;/span\u0026gt; 17 \u0026lt;/section\u0026gt; 18\u0026lt;/footer\u0026gt; 若想浏览次数出现在文章开头，参考【Hugo】Stack主题自定义修改，但是会有bug，咱小白先弄简单的。\n参考文献 小白hugo博客装修笔记（2）- B1ain’s Blog\nHugo-stackの美化 II\nHugo Stack 魔改美化 | Naive Koala\nStack 主题的自定义 | L1nSn0w’s Log\n【Hugo】Stack主题自定义修改\n","date":"2025-10-24T19:19:24+08:00","permalink":"https://bobqaq003.github.io/Kuka-hugo/p/hugohugo%E7%BE%8E%E5%8C%96/","title":"【Hugo】Hugo美化"},{"content":"对标签 y 用基于质心的扰动 转移矩阵变化 按照对特征的逻辑，每个节点标签扰动都不同，所以得到的保留概率p和扰动概率q，都是节点向量，每个节点都是不同的概率：CTRL + C\n比如扰动2000个节点，那么:\np=torch.Size([0.7,0.7,0.8\u0026hellip;.], 2000)，\nq=torch.Size([0.1,0.1,0.2\u0026hellip;], 2000)\n但是原来采用RR的扰动，对标签的保留概率p和扰动概率q是标量，\n不论多少节点，p=0.7, q=0.1\n这是不同的地方，目前为止没什么大问题，问题是在标签部分需要计算一个转移矩阵data.T，大小是 [num_classes, num_classes]，T[i,j] 表示真实类别 i 被扰动成类别 j 的概率，假如是个3分类，T就是这样： $$ T=\\left[\\begin{array}{ccc} 0.7 \u0026 0.1 \u0026 0.1 \\\\ 0.1 \u0026 0.7 \u0026 0.1 \\\\ 0.1 \u0026 0.1 \u0026 0.7 \\end{array}\\right] $$ 标签 0 有 70% 的概率保持为标签 0，10% 的概率变为标签 1，10% 的概率变为标签 2\n如果计算每个节点标签的扰动概率不同，那么转移矩阵data.T就要变成三维的了：[num_nodes,num_classes, num_classes]，节点n的标签 i被扰动成类别 j 的概率： $$ T=\\left[\\left[\\begin{array}{ccc} 0.7 \u0026 0.1 \u0026 0.1 \\\\ 0.1 \u0026 0.7 \u0026 0.1 \\\\ 0.1 \u0026 0.1 \u0026 0.7 \\end{array}\\right],\\left[\\begin{array}{ccc} 0.8 \u0026 0.1 \u0026 0.1 \\\\ 0.1 \u0026 0.8 \u0026 0.1 \\\\ 0.1 \u0026 0.1 \u0026 0.8 \\end{array}\\right]...\\right] $$前向传播变化 得到上面三维的转移矩阵data.T，还要继续修改forward部分：\n1# p_yp_x = torch.matmul(p_y_x, data.T) if self.forward_correction else p_y_x # P(y\u0026#39;|x\u0026#39;) 2p_yp_x = torch.bmm(p_y_x.unsqueeze(1), data.T).squeeze(1) if self.forward_correction else p_y_x # P(y\u0026#39;|x\u0026#39;) 还有metrics部分：\n1metrics = { 2 \u0026#39;train/loss\u0026#39;: loss.item(), 3 \u0026#39;train/acc\u0026#39;: self.accuracy(pred=p_y_x[data.train_mask], target=data.y[data.train_mask]) * 100, 4 # \u0026#39;train/maxacc\u0026#39;: data.T[0, 0].item() * 100, 5 \u0026#39;train/maxacc\u0026#39;: data.T.diagonal(dim1=1, dim2=2).mean().item() * 100 6} 但是准确率变得极低\n原因可能：\n按照目前的翻转概率（84%）进行扰动，训练中剩下的正确的节点就比较少，模型学到的错误标签较多 高噪声下，KProp层的传播起负面效果，污染了干净节点，没有专门的抗噪声设计 解决：\nKProp加上去偏层 Kprop加上噪声过滤的方法 ","date":"2025-10-24T15:58:38+08:00","permalink":"https://bobqaq003.github.io/Kuka-hugo/p/privacylpgnn/","title":"【Privacy】LPGNN"},{"content":"按度数分布划分区间，总隐私预算以区间 Yuan Y, Lei D, Fan Q, et al. Achieving Adaptive Privacy-Preserving Graph Neural Networks Training in Cloud Environment[C]//2024 IEEE 12th International Conference on Information, Communication and Networks (ICICN). IEEE, 2024: 181-186.\nYuan Y, Lei D, Zhang C, et al. Personalized differential privacy graph neural network[J]. IEEE/CAA Journal of Automatica Sinica, 2025.\n给出一个总体区间 $[ε_1, ε_2]$，再按节点度数把用户分桶，并把 $[ε_1, ε_2]$切成多个子区间；每个用户的“初始”隐私预算 $ε_s$ 会从对应子区间里随机采样（按指数分布采样），因此不同用户拿到的起始预算彼此不同\n根据度数的大小，我们可以将这些节点划分成几个区间。例如：\n区间1：度数小于等于 10 区间2：度数大于 10 且小于等于 50 区间3：度数大于 50 根据区间的划分，隐私预算会在区间 $[ε₁, ε₂]$ 内进行分配。假设$ε₁ = 0.1$，$ε₂ = 1$，并且使用指数分布来决定隐私预算的具体值：\n对于区间1，为其分配较高的隐私预算（如接近$ε₂ = 1$）。 对于区间，隐私预算会适中。 对于区间3，隐私预算会较低（接近$ε₁ = 0.1$）。 隐私预算的分配在度数区间的划分上使用了指数分布。其公式为： $$ \\text{Sample from exponential distribution } f(y, \\lambda) = \\lambda e^{-\\lambda y}, \\, (y \\geq 0) $$ 之后用户用各自的 $ε_s$ 加噪：$\\hat X_s=f(X_s)+\\mathrm{Lap}(\\Delta f/ε_s)$，\nAPPGNN按照节点度数划分为若干个区间，并将 隐私预算区间 对应划分，根据节点度数的 比例分布，将其 映射到指数分布的分位数区间，从中 采样出个性化的隐私预算。\n拓扑重要性个性化，总隐私预算以区间 Lei D, Song Z, Yuan Y, et al. Achieving Personalized Privacy-Preserving Graph Neural Network via Topology Awareness[C]//Proceedings of the ACM on Web Conference 2025. 2025: 3552-3560.\n提出“邻接信息熵”（Adjacency Information Entropy, AIE）来衡量节点拓扑重要性，既考虑直连邻居也考虑间接关系：先算邻接度 $AD_u=\\sum_{v\\in \\mathcal N_u} D_v$，再定义概率 $p_u=D_u/AD_v$，最后得信息熵式的 $AIE_u=-\\sum_{v\\in \\mathcal N_u}(p_u\\log_2 p_u),p_v$（式(4)–(6)）。重要性越高→隐私敏感度越高。\n将总预算区间 $[,\\epsilon_b,\\epsilon_e,]$ 按节点隐私敏感度分成 $M$ 个等级与对应子区间，并假设预算在该区间内服从指数分布（真实网络度分布常呈幂律，少数节点很重要）。通过指数分布分位点把 $[,\\epsilon_b,\\epsilon_e,]$ 切成 $(\\epsilon_b,\\epsilon_1],(\\epsilon_1,\\epsilon_2],\\dots,(\\epsilon_{M-2},\\epsilon_e]$，切分边界用式(7)(8)的分位数关系确定；重要节点→分到更小的 $\\epsilon$（更强保护/更大噪声），不太重要的节点→更大的 $\\epsilon$（更少噪声）。每个节点最终从其子区间随机采样得到个性化预算 $\\epsilon_i$。\n各节点用自己的 $\\epsilon_i$ 做拉普拉斯机制：$\\hat X_i=f(X_i)+\\mathrm{Lap}(\\Delta f/\\epsilon_i)$（式(3)、(9)），并用随机响应扰动标签（式(12)），实现特征+标签双重保护。\n因不同邻居被加的噪声强度不同，直接平均会放大高噪声邻居的负面影响。论文据“越重要→预算越小→噪声越大”的链条，给重要邻居更小权重： $$ W_{u,v}=1+\\frac{1}{D_u}-\\frac{AIE_v}{\\sum_{i\\in Ner_u}AIE_{u,i}+AIE_u}, $$ 再做加权聚合（式(10)(11)）。这样能抑制差异化DP噪声对表示学习的影响。\nTDP-GNN 通过拓扑结构识别节点重要性，划分为多个隐私敏感度等级，映射到指数分布的预算区间并采样个性化预算，再结合加权聚合抑制噪声。\n上下文多臂赌博机（CMAB）算法分配（区间） Zhang X, Zhou Y, Hu M, et al. BGTplanner: Maximizing Training Accuracy for Differentially Private Federated Recommenders via Strategic Privacy Budget Allocation[J]. IEEE Transactions on Services Computing, 2025.\n步骤 1：生成奖励的预测\n对于每个动作 $a_t$ 和上下文 $X_t$，BGTplanner使用高斯过程回归模型预测奖励 $r_t$： $$ \\mu(z_t) = \\text{GPR}(a_t, X_t) $$ 步骤 2：计算动作的评分\n根据预测的奖励 $\\mu(z_t)$，为每个可能的动作（隐私预算分配方案）计算一个评分 $\\beta_t(a)$，公式如下： $$ \\beta_t(a) = \\mu(z_t) - \\langle \\epsilon_{\\text{total}} - \\epsilon_t, \\lambda_t \\rangle $$​\t其中，$\\lambda_t$ 是用于长期隐私预算约束的拉格朗日乘子，确保在整个训练过程中不会超出总预算。\n步骤 3：选择最优的隐私预算分配方案 $\\gamma$ 是探索和利用的权衡参数，控制着系统是否偏向于选择当前最优的动作（利用）或探索其他可能的动作。 $A$ 是动作空间的大小，表示可能的隐私预算分配方案的数量。 步骤 4：更新隐私预算消耗 在每轮训练之后，BGTplanner通过隐私预算消耗函数来计算实际消耗的隐私预算 $\\epsilon_t$，并更新剩余预算。 假设我们有如下参数：\n总隐私预算 $\\epsilon_{\\text{total}} = 10$ 隐私预算区间：$\\epsilon_{\\text{min}} = 1, \\epsilon_{\\text{max}} = 5$ 每轮的隐私预算分配动作是从区间 $[1, 5]$ 中选择的。 在某个训练回合中，BGTplanner预测奖励为：\n$$ \\mu(z_t) = 0.8 \\quad (\\text{基于历史信息和上下文的奖励预测}) $$ 接着，BGTplanner计算所有可能动作的评分，并选择评分最高的动作。例如，假设动作 $a_1$ 得分为 0.9，动作 $a_2$ 得分为 0.7，最终选择 $a_1$ 作为隐私预算分配方案。\nBGTplanner 每轮都用 CMAB 从一组预算选项中，智能选一个最合适的隐私预算来用\n探讨隐私预算的推荐值 Du W, Ma X, Dong W, et al. Calibrating privacy budgets for locally private graph neural networks[C]//2021 International Conference on Networking and Network Applications (NaNA). IEEE, 2021: 23-29.\n采用了 Multi-bit LDP Mechanism (LPGNN的方法)对用户特征进行扰动:\n输入：\n用户特征向量$ x∈[α,β]^d$ 隐私预算$\\epsilon$ 控制参数 m（每次扰动的特征维度数） 输出：\n扰动后的特征向量 $ x∈{-1,0,1}^d$ 通过链路预测准确率和加入属性推断攻击后的F1-score值推荐隐私预算值\n项目 内容 目标 在 LDP 保护的 GNN 中合理选择隐私预算 ε 方法 利用属性推断攻击效果作为隐私度量，结合链路预测准确率评估效用 隐私机制 Multi-bit LDP 机制，用户本地扰动特征，服务器无偏重构 推荐 ε 值 0.5 ~ 1（视具体业务对隐私和效用的需求） 基于遗传算法（GA）的隐私预算分配 Li Y, Song X, Tu Y, et al. GAPBAS: Genetic algorithm-based privacy budget allocation strategy in differential privacy K-means clustering algorithm[J]. Computers \u0026amp; Security, 2024, 139: 103697.\n通过分析噪声对质心的影响，推导出 最小隐私预算$ε_m$： $$ ε_m=(\\frac{200k^3d+(1+d)^2}{N^2}(1+ρ^2))^{1/2} $$ 其中：\nk：聚类数；d：数据维度；N：样本数量；ρ：噪声相关系数（通常取 0.225）； 每轮预算必须满足：$ε_t$≥$ε_m$，否则噪声过大导致质心不收敛。\n每个个体是一个长度为 $T$ 的浮点数组：${ε_1,ε_2,\u0026hellip;,ε_T}$ GAPBAS 将每轮隐私预算组合成序列，作为遗传算法的个体，在满足总预算和最小预算约束下，优化出使聚类效果（NICV）最优的预算分配策略。\n基于隐私安全等级（Privacy Security Level, PSL） Shen Z, He S, Wang H, et al. A differential privacy budget allocation method combining privacy security level[J]. Journal of Communications and Information Networks, 2023, 8(1): 90-98.\n提出 PSL 方法：为每个位置分配一个“隐私安全等级”，并据此动态分配隐私预算 $ε$，实现 个性化、拓扑感知的隐私保护。\n步骤：\n使用 P-series（p-级数） 为初始敏感位置分配隐私预算\n使用 P-series 为初始敏感位置分配预算： $$ \\varepsilon_{m} = \\frac{\\varepsilon}{\\zeta(p)} \\times \\frac{1}{m^{p}}, \\quad m \\in \\mathbb{N}^{+}, \\quad p \u003e 1 $$ $\\varepsilon$：总隐私预算； $\\zeta(p)$：P级数收敛值（如 p=2 时，$\\zeta(2)= π²/6$； m：敏感位置编号（按重要性排序）； 结果：重要位置（m 小）获得更大预算（更小噪声） 根据 距离与节点度 为敏感点的邻居分配预算，并支持 动态时间调整\nPSL定义： $$ \\mathrm{PSL}(k_{m}) = \\lambda \\times \\varepsilon_{m} = \\lambda \\times \\frac{\\varepsilon}{\\zeta(p)} \\times m^{p} $$ PSL 与预算$\\varepsilon$ 成反比； $\\lambda$ 为调节参数; 用于衡量位置的“隐私敏感度”。 将 PSL 映射为隐私预算$ε$，满足 $\\epsilon × PSL = \\gamma$（$\\gamma$ 为常数）\n假设：\n敏感节点 $k_1$ 的 PSL = 0.6079； 邻居 A 距离为 1，邻居 B 距离为 2； NPS = {A, B}； 则： $$ \\mathrm{PSL}_{A} = \\frac{1/1}{(1/1 + 1/2)} \\times 0.6079 = 0.4053, \\\\ \\mathrm{PSL}_{B} = \\frac{1/2}{(1/1 + 1/2)} \\times 0.6079 = 0.2026 $$ 再映射回预算： $$ \\epsilon_{A} = \\frac{\\gamma}{\\mathrm{PSL}_{A}} = \\frac{0.5}{0.4053} \\approx 1.23 , \\\\ \\epsilon_{B} = \\frac{\\gamma}{\\mathrm{PSL}_{B}} = \\frac{0.5}{0.2026} \\approx 2.47 $$ PSL 方法通过 P-series 为敏感位置分配递减预算，再结合距离与节点度为邻居分配个性化预算，并支持时间动态调整，实现“重要位置多留数据，敏感位置多加噪声”的精细化隐私保护。\n","date":"2025-10-23T19:00:59+08:00","permalink":"https://bobqaq003.github.io/Kuka-hugo/p/privacy%E8%87%AA%E9%80%82%E5%BA%94%E9%9A%90%E7%A7%81%E9%A2%84%E7%AE%97%E5%88%86%E9%85%8D/","title":"【Privacy】自适应隐私预算分配"}]