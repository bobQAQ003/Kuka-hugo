[{"content":"引入PJAX 从 MoOx/pjax（不带JQuery）这里引入 我们需要刷新的是左侧边栏 ，右侧边栏 和中间的内容 从源代码可以发现这些元素都被一个\u0026lt;div class=\u0026quot;main-container\u0026quot;\u0026gt;...\u0026lt;/div\u0026gt;包裹着 根据官方文档，在layouts/partials/footer/custom.html加入以下代码来引入PJAX： 1 2 3 4 5 6 7 8 9 \u0026lt;!-- 【custom.html】 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/pjax/pjax.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var pjax = new Pjax({ selectors: [ \u0026#34;.main-container\u0026#34; ] }) \u0026lt;/script\u0026gt; 我这里先创建layouts/partials/footer/pjax.html，再在custom.html里引用 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- pjax.html --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/pjax/pjax.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var pjax = new Pjax({ selectors: [ \u0026#34;.main-container\u0026#34;, ] }) \u0026lt;/script\u0026gt; \u0026lt;!-- custom.html --\u0026gt; {{partial \u0026#34;footer/pjax.html\u0026#34;}} 文章样式修复 问题描述： 引入pjax后，重启hugo server -D，发现文章样式丢失，手动点击刷新可以恢复 产生原因： \u0026lt;body\u0026gt;标签中的class名缺失article-page，导致文章样式丢失 解决思路： 通过官方提供了数据预处理方法，来预处理数据，获取到新页面的className，然后我们手动将这className设置到\u0026lt;body\u0026gt;上 具体步骤： 修改layouts/partials/footer/pjax.html，（如果是在custom.html加了pjax就在那里改）引入以下代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script\u0026gt; pjax._handleResponse = pjax.handleResponse; pjax.handleResponse = function(responseText, request, href, options) { if (request.responseText.match(\u0026#34;\u0026lt;html\u0026#34;)) { if (responseText) { // 将新页面的html字符串解析成DOM对象 let newDom = new DOMParser().parseFromString(responseText, \u0026#39;text/html\u0026#39;); // 获取新页面中body的className，并设置回当前页面 let bodyClass = newDom.body.className; document.body.setAttribute(\u0026#34;class\u0026#34;, bodyClass) } // 放行，交给pjax自己处理 pjax._handleResponse(responseText, request, href, options); } else { // handle non-HTML response here } } \u0026lt;/script\u0026gt; 主题切换修复 问题描述： 切换页面后，左下角切换主题颜色按钮不生效 产生原因： 在Stack主题源码assets/ts/colorScheme.ts中，脚本初始化时，会给元素绑定一个点击事件。但因为页面切换了，替换了该元素，但该元素没有重新绑定点击事件，导致点击主题切换失效 解决思路：\n在PJAX切换完页面后，重新执行一遍colorScheme.ts的初始化，使元素重新绑定点击事件 而colorScheme.ts被main.ts引用，在main.ts中执行了初始化，并且main.ts生成了全局变量 Stack 所以在PJAX执行完后，使用全局变量 Stack ，执行里面的初始化方法，重新执行一遍脚本，来绑定点击事件 PJAX官方文档也提供了PJAX执行完后的事件pjax:complete，监听这个事件，Stack 执行初始化就好 具体步骤：\n修改layouts/partials/footer/pjax.html，引入以下代码 1 2 3 4 5 6 \u0026lt;script\u0026gt; document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { // Stack脚本初始化 window.Stack.init(); }) \u0026lt;/script\u0026gt; 文章搜索修复 问题描述： 使用文章搜索功能时，输入关键词，无任何搜索记录 产生原因： 查看assets/ts/search.tsx文件，情况和上面的colorScheme.ts类似，存在绑定事件 解决思路： 把 search.tsx 初始化内容封装为一个函数，并把函数 export 出来 由 main.ts 引入这个函数，并放到 Stack.init() 的方法中，利用此方法来重新初始化搜索脚本 具体步骤： 修改assets/ts/search.tsx代码，封装方法并export 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * 把window.addEventListener(\u0026#39;load\u0026#39; ...这部分代码注释掉 * 初始化工作交给Stack.init()处理了，不需要这个了 */ ... function searchInit() { let search = document.querySelector(\u0026#39;.search-result\u0026#39;); if (search) { const searchForm = document.querySelector(\u0026#39;.search-form\u0026#39;) as HTMLFormElement, searchInput = searchForm.querySelector(\u0026#39;input\u0026#39;) as HTMLInputElement, searchResultList = document.querySelector(\u0026#39;.search-result--list\u0026#39;) as HTMLDivElement, searchResultTitle = document.querySelector(\u0026#39;.search-result--title\u0026#39;) as HTMLHeadingElement; new Search({ form: searchForm, input: searchInput, list: searchResultList, resultTitle: searchResultTitle, resultTitleTemplate: window.searchResultTitleTemplate }); } } export { searchInit } 修改assets/ts/main.ts，引入搜索初始化方法并调用 1 2 3 4 5 6 7 8 9 ... import { searchInit } from \u0026#34;ts/search\u0026#34;; let Stack = { init: () =\u0026gt; { ... // 调用search脚本初始化方法 searchInit(); } } 从Stack模板文件复制layouts\\partials\\footer\\components\\script.html，把\u0026quot;JSXFactory\u0026quot; \u0026quot;createElement\u0026quot;补充，改法参考layouts\\page\\search.html， 搜索内容跳转修复 问题描述：\n能进行搜索，但搜索出来的内容并没有被PJAX识别到，导致PJAX没有拦截，进而导致页面刷新 产生原因：\n阅读 search.tsx 源码可知，搜索内容的数据，是通过 React.render() 动态渲染回页面的，这些动态数据没有被PJAX识别到 解决思路： PJAX官方文档提供给了重新解析数据的方法，所以在 React.render() 之后，调用PJAX方法，重新解析页面即可 具体步骤： 修改assets/ts/search.tsx，在动态渲染数据方法末尾让pjax重新解析文档 1 2 3 4 5 6 7 8 9 private async doSearch(keywords: string[]) { ... /* 方法末尾，让pjax重新解析文档数据，识别动态渲染的数据 虽然当前文件没有pjax对象，但最后静态页面会生成一个整体的js文件 pjax对象那时就能识别到，就可成功调用 */ pjax.refresh(document); } KaTeX修复 KaTex渲染失效 问题描述： 含有 数学公式(KaTeX) 的文章，里面的数学公式不能正常渲染出来 产生原因： 阅读源码layouts/partials/article/components/math.html，KaTeX渲染公式需要执行renderMathInElement，而PJAX的无刷新技术无法触发DOMContentLoaded的监听 解决思路： 将renderMathInElement封装为函数，交由PJAX加载结束后执行 具体操作： 修改layouts/partials/article/components/math.html，添加一个元素标签，便于判断文档是否使用了KaTeX 1 2 ... \u0026lt;div class=\u0026#34;math-katex\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; layouts/partials/footer/pjax.html，引入以下代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;script\u0026gt; async function renderKaTeX() { // 判断当前页面是否有KateX let katex = document.querySelector(\u0026#34;.math-katex\u0026#34;); if (!katex) { return; } // 等待函数加载成功后，再执行渲染方法 while (typeof renderMathInElement !== \u0026#39;function\u0026#39;) { await delay(500); } // KaTeX渲染方法 renderMathInElement(document.body, { delimiters: [ { left: \u0026#34;$$\u0026#34;, right: \u0026#34;$$\u0026#34;, display: true }, { left: \u0026#34;$\u0026#34;, right: \u0026#34;$\u0026#34;, display: false }, { left: \u0026#34;\\\\(\u0026#34;, right: \u0026#34;\\\\)\u0026#34;, display: false }, { left: \u0026#34;\\\\[\u0026#34;, right: \u0026#34;\\\\]\u0026#34;, display: true } ], ignoredClasses: [\u0026#34;gist\u0026#34;] }); } /** * 同步延迟 */ function delay(time) { return new Promise(resolve =\u0026gt; { setTimeout(resolve, time) }) } document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { renderKaTeX(); }) \u0026lt;/script\u0026gt; 引用块和公式块冲突 问题描述：\n在引用块中又写了公式块，最终渲染出这样： 产生原因：\nTypora 内置的 Markdown 解析器 先合并 blockquote 行、再交给 MathJax，所以Typora显示正常 而 Hugo（Goldmark 解析器）逐行解析，每一行前面都带着 \u0026gt;，于是 Goldmark 把 \u0026gt; 转义成 \u0026gt; 塞进公式节点，KaTeX 收到的是：\u0026gt; \\mu(z_t) = 0.8 \\quad (...) 解决思路：\n目前没有很好的解决方法，只能是避免混用 浏览量统计失效 问题描述： 先前使用的vercount在引入Pjax后失效，必须手动刷新才会生效 产生原因： 原始的Vercount脚本在页面第一次加载时执行，它会在页面中插入浏览量显示的元素。但是当使用Pjax加载x新页面时，脚本不会自动重新执行，因此新页面中的浏览量元素没有被插入。 解决思路： 动态重新加载脚本，移除旧脚本，清除之前的执行状态， 创建新脚本，等待 pjax:complete 完成后再添加到 DOM 中 具体步骤： layouts/partials/footer/pjax.html，引入代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;script\u0026gt; // 浏览量统计 function initVerCount() { // 移除已存在的 Vercount 脚本 const existingScript = document.querySelector(\u0026#39;script[src=\u0026#34;https://cn.vercount.one/js\u0026#34;]\u0026#39;); if (existingScript) { existingScript.remove(); } // 创建新的 Vercount 脚本 const newScript = document.createElement(\u0026#39;script\u0026#39;); newScript.src = \u0026#39;https://cn.vercount.one/js\u0026#39;; newScript.defer = true; // 添加到 head 中 document.head.appendChild(newScript); } document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { ... initVerCount(); }) \u0026lt;/script\u0026gt; 进度条加载 问题描述： 使用了PJAX后，原先采用的进度条失效，采用另外的方法 具体步骤： 前往【topbar】下载zip包，将解压后的 topbar.min.js 放到assets\\js\\topbar.min.js 通过监听PJAX两个事件 pjax:send 和 pjax:complete 实现伪进度条 layouts/partials/footer/pjax.html，引入代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 {{ with resources.Get \u0026#34;js/topbar.min.js\u0026#34; }} \u0026lt;!-- 引入本地JS脚本 --\u0026gt; \u0026lt;script src={{ .Permalink }}\u0026gt;\u0026lt;/script\u0026gt; {{ end }} \u0026lt;script\u0026gt; // 修改进度条颜色 topbar.config({ barColors: { \u0026#39;0\u0026#39;: \u0026#39;rgba(255, 255, 255, 1)\u0026#39;, // 进度0%白色 \u0026#39;1.0\u0026#39;: \u0026#39;rgba(0, 149, 234, 1)\u0026#39; // 进度100%蓝色 } }) document.addEventListener(\u0026#39;pjax:send\u0026#39;, () =\u0026gt; { // 显示顶部进度条 topbar.show(); }) document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { .... // 隐藏顶部进度条 topbar.hide(); }) \u0026lt;/script\u0026gt; ","date":"2025-10-25T09:40:08+08:00","permalink":"https://bobqaq003.github.io/Kuka-hugo/p/hugo%E7%BE%8E%E5%8C%96%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","title":"【Hugo】美化过程中遇到的问题"},{"content":"yaml配置 添加行号后复制代码会复制行号的问题 参考 小白hugo博客装修笔记（2）- B1ain’s Blog\n手动复制有行号 在/assets/scss/custom.scss 文件中添加如下内容，将行号设定为不可选中\n1 2 3 4 // 手动复制禁止复制行号 .highlight .ln { user-select: none; } copy按钮复制带行号 修改/themes/hugo-theme-stack/assets/ts/main.ts文件中的复制按钮逻辑。\n但具体情况是，在本地进行调试时，确实手动复制和copy复制都会涉及行号。当部署到github pages打开后，copy不会有影响，反而手动复制可能会复制到行号。\n所以具体情况看个人博客部署情况吧。反正能用\n左边栏副标题换行 参考 Hugo-stackの美化 II\n找到 layouts/partials/sidebar/left.html，复制到博客的同名主文件夹下：\n1 2 3 4 5 \u0026lt;div class=\u0026#34;site-meta\u0026#34;\u0026gt; \u0026lt;h1 class=\u0026#34;site-name\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;{{ .Site.BaseURL | relLangURL }}\u0026#34;\u0026gt;{{ .Site.Title }}\u0026lt;/a\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h2 class=\u0026#34;site-description\u0026#34;\u0026gt;{{ .Site.Params.sidebar.subtitle }}\u0026lt;/h2\u0026gt; \u0026lt;h2 class=\u0026#34;site-description\u0026#34;\u0026gt;{{ .Site.Params.sidebar.subtitle | safeHTML }}\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; 当然也可以修改stack模板下hugo-theme-stack里的文件，但不建议，毕竟还要通过源码进行学习。\n然后在 hugo.yaml 中在要换行的地方加上 \u0026lt;br\u0026gt;：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 languages: en: languageName: English title: Example Site weight: 1 params: sidebar: subtitle: Example description zh-cn: languageName: 中文 title: KukaDam weight: 2 params: sidebar: subtitle: \u0026#34;晚来天欲雪\u0026lt;br\u0026gt;能饮一杯无\u0026#34; Markdown样式 键盘样式 参考 Hugo Stack 魔改美化 | Naive Koala\n在 /assets/scss/custom.scss 中加入以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 键盘样式 kbd { margin: 0 .1em; padding: .1em .6em; font-size: .8em; color: #242729; background: #fff; border: 1px solid #adb3b9; border-radius: 3px; box-shadow: 0px 1px 0 rgba(12, 13, 14, 0.2), 0 0 0 2px #fff inset; white-space: nowrap; vertical-align: middle; font-family: monospace; } 这样就可以呈现如下 Markdown 中的键盘样式： \u0026lt;kbd\u0026gt;CTRL\u0026lt;/kbd\u0026gt; + \u0026lt;kbd\u0026gt;C\u0026lt;/kbd\u0026gt;\nCTRL + C\n图床链接图片居中 目前 Stack 默认只支持本地引用的图片居中，而在使用 url 图片链接时没有居中格式。在博客主文件夹同名位置 /assets/scss/partials/layout/article.scss Line 256 处（同级任意位置）增加以下代码：\n1 2 3 4 5 6 7 // Center image from url source p \u0026gt; img { display: block; margin: 0 auto; max-width: 100%; height: auto; } 组件 顶部返回按钮 参考Stack 主题的自定义 | L1nSn0w’s Log\n个人不是很喜欢返回键把左边菜单隐藏，给自己留个档。\n加载进度条 在layouts/partials/footer/custom.html加入代码：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;!-- 加载进度条 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/zhixuan2333/gh-blog@v0.1.0/js/nprogress.min.js\u0026#34; integrity=\u0026#34;sha384-bHDlAEUFxsRI7JfULv3DTpL2IXbbgn4JHQJibgo5iiXSK6Iu8muwqHANhun74Cqg\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/gh/zhixuan2333/gh-blog@v0.1.0/css/nprogress.css\u0026#34; integrity=\u0026#34;sha384-KJyhr2syt5+4M9Pz5dipCvTrtvOmLk/olWVdfhAp858UCa64Ia5GFpTN7+G4BWpE\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; /\u0026gt; \u0026lt;script\u0026gt; NProgress.start(); document.addEventListener(\u0026#34;readystatechange\u0026#34;, () =\u0026gt; { if (document.readyState === \u0026#34;interactive\u0026#34;) NProgress.inc(0.8); if (document.readyState === \u0026#34;complete\u0026#34;) NProgress.done(); }); \u0026lt;/script\u0026gt; 但这个方法可能在引入pjax后会失效，需要查看pjax文档进行监听\n樱花背景 下载地址【sakura.js】(CTRL + C 保存)，并放到assets/background文件夹下\n在layouts/partials/footer/custom.html加入代码：\n1 2 \u0026lt;!-- 樱花背景 --\u0026gt; \u0026lt;script src={{ (resources.Get \u0026#34;background/sakura.js\u0026#34;).Permalink }}\u0026gt;\u0026lt;/script\u0026gt; 文章最后修改时间 在hugo.yaml加入代码：\n1 2 3 4 5 6 7 8 9 10 frontmatter: # 按优先级排序： # :git - 文件提交修改时间 # lastmod - 文章里 lastmod 字段 # :fileModTime - 文件修改时间 # :default - 默认时间 lastmod: [\u0026#34;:git\u0026#34;, \u0026#34;lastmod\u0026#34;, \u0026#34;:fileModTime\u0026#34;, \u0026#34;:default\u0026#34;] enableGitInfo: true gitRepo: \u0026#34;https://github.com/your_username/your_username.github.io\u0026#34; 这个方法比较简单，但是时间会出现在文章末尾：\n更新时间的格式去 hugo.yaml 中的 params.dateFormat.lastUpdated 进行修改：\n1 2 3 dateFormat: published: 2006-01-02 lastUpdated: 2006-01-02 留档：文章开头显示更新时间，参考【Hugo】Stack主题自定义修改\n页面浏览量 这里用的是vercount\n修改layouts/partials/footer/custom.html，引入脚本：\n1 \u0026lt;script defer src=\u0026#34;https://cn.vercount.one/js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 修改layouts/partials/article/components/footer.html，（没有文件夹可以从模板中复制）在合适的位置下加入代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;footer class=\u0026#34;article-footer\u0026#34;\u0026gt; {{ partial \u0026#34;article/components/tags\u0026#34; . }} {{ if and (.Site.Params.article.license.enabled) (not (eq .Params.license false)) }} \u0026lt;section class=\u0026#34;article-copyright\u0026#34;\u0026gt; ... \u0026lt;/section\u0026gt; {{ end }} {{- if ne .Lastmod .Date -}} \u0026lt;section class=\u0026#34;article-lastmod\u0026#34;\u0026gt; ... \u0026lt;/section\u0026gt; {{- end -}} \u0026lt;section\u0026gt; 页面浏览量\u0026lt;span id=\u0026#34;vercount_value_page_pv\u0026#34;\u0026gt;loading... \u0026lt;/span\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/footer\u0026gt; 若想浏览次数出现在文章开头，参考【Hugo】Stack主题自定义修改，但是会有bug，咱小白先弄简单的。\n参考文献 小白hugo博客装修笔记（2）- B1ain’s Blog\nHugo-stackの美化 II\nHugo Stack 魔改美化 | Naive Koala\nStack 主题的自定义 | L1nSn0w’s Log\n【Hugo】Stack主题自定义修改\n","date":"2025-10-24T19:19:24+08:00","permalink":"https://bobqaq003.github.io/Kuka-hugo/p/hugohugo%E7%BE%8E%E5%8C%96/","title":"【Hugo】Hugo美化"},{"content":"对标签 y 用基于质心的扰动 转移矩阵变化 按照对特征的逻辑，每个节点标签扰动都不同，所以得到的保留概率p和扰动概率q，都是节点向量，每个节点都是不同的概率：CTRL + C\n比如扰动2000个节点，那么:\np=torch.Size([0.7,0.7,0.8\u0026hellip;.], 2000)，\nq=torch.Size([0.1,0.1,0.2\u0026hellip;], 2000)\n但是原来采用RR的扰动，对标签的保留概率p和扰动概率q是标量，\n不论多少节点，p=0.7, q=0.1\n这是不同的地方，目前为止没什么大问题，问题是在标签部分需要计算一个转移矩阵data.T，大小是 [num_classes, num_classes]，T[i,j] 表示真实类别 i 被扰动成类别 j 的概率，假如是个3分类，T就是这样： $$ T=\\left[\\begin{array}{ccc} 0.7 \u0026 0.1 \u0026 0.1 \\\\ 0.1 \u0026 0.7 \u0026 0.1 \\\\ 0.1 \u0026 0.1 \u0026 0.7 \\end{array}\\right] $$ 标签 0 有 70% 的概率保持为标签 0，10% 的概率变为标签 1，10% 的概率变为标签 2\n如果计算每个节点标签的扰动概率不同，那么转移矩阵data.T就要变成三维的了：[num_nodes,num_classes, num_classes]，节点n的标签 i被扰动成类别 j 的概率： $$ T=\\left[\\left[\\begin{array}{ccc} 0.7 \u0026 0.1 \u0026 0.1 \\\\ 0.1 \u0026 0.7 \u0026 0.1 \\\\ 0.1 \u0026 0.1 \u0026 0.7 \\end{array}\\right],\\left[\\begin{array}{ccc} 0.8 \u0026 0.1 \u0026 0.1 \\\\ 0.1 \u0026 0.8 \u0026 0.1 \\\\ 0.1 \u0026 0.1 \u0026 0.8 \\end{array}\\right]...\\right] $$前向传播变化 得到上面三维的转移矩阵data.T，还要继续修改forward部分：\n1 2 # p_yp_x = torch.matmul(p_y_x, data.T) if self.forward_correction else p_y_x # P(y\u0026#39;|x\u0026#39;) p_yp_x = torch.bmm(p_y_x.unsqueeze(1), data.T).squeeze(1) if self.forward_correction else p_y_x # P(y\u0026#39;|x\u0026#39;) 还有metrics部分：\n1 2 3 4 5 6 metrics = { \u0026#39;train/loss\u0026#39;: loss.item(), \u0026#39;train/acc\u0026#39;: self.accuracy(pred=p_y_x[data.train_mask], target=data.y[data.train_mask]) * 100, # \u0026#39;train/maxacc\u0026#39;: data.T[0, 0].item() * 100, \u0026#39;train/maxacc\u0026#39;: data.T.diagonal(dim1=1, dim2=2).mean().item() * 100 } 但是准确率变得极低\n原因可能：\n按照目前的翻转概率（84%）进行扰动，训练中剩下的正确的节点就比较少，模型学到的错误标签较多 高噪声下，KProp层的传播起负面效果，污染了干净节点，没有专门的抗噪声设计 解决：\nKProp加上去偏层 Kprop加上噪声过滤的方法 ","date":"2025-10-24T15:58:38+08:00","permalink":"https://bobqaq003.github.io/Kuka-hugo/p/privacylpgnn/","title":"【Privacy】LPGNN"},{"content":"按度数分布划分区间，总隐私预算以区间 Yuan Y, Lei D, Fan Q, et al. Achieving Adaptive Privacy-Preserving Graph Neural Networks Training in Cloud Environment[C]//2024 IEEE 12th International Conference on Information, Communication and Networks (ICICN). IEEE, 2024: 181-186.\nYuan Y, Lei D, Zhang C, et al. Personalized differential privacy graph neural network[J]. IEEE/CAA Journal of Automatica Sinica, 2025.\n给出一个总体区间 $[ε_1, ε_2]$，再按节点度数把用户分桶，并把 $[ε_1, ε_2]$切成多个子区间；每个用户的“初始”隐私预算 $ε_s$ 会从对应子区间里随机采样（按指数分布采样），因此不同用户拿到的起始预算彼此不同\n根据度数的大小，我们可以将这些节点划分成几个区间。例如：\n区间1：度数小于等于 10 区间2：度数大于 10 且小于等于 50 区间3：度数大于 50 根据区间的划分，隐私预算会在区间 $[ε₁, ε₂]$ 内进行分配。假设$ε₁ = 0.1$，$ε₂ = 1$，并且使用指数分布来决定隐私预算的具体值：\n对于区间1，为其分配较高的隐私预算（如接近$ε₂ = 1$）。 对于区间，隐私预算会适中。 对于区间3，隐私预算会较低（接近$ε₁ = 0.1$）。 隐私预算的分配在度数区间的划分上使用了指数分布。其公式为： $$ \\text{Sample from exponential distribution } f(y, \\lambda) = \\lambda e^{-\\lambda y}, \\, (y \\geq 0) $$ 之后用户用各自的 $ε_s$ 加噪：$\\hat X_s=f(X_s)+\\mathrm{Lap}(\\Delta f/ε_s)$，\nAPPGNN按照节点度数划分为若干个区间，并将 隐私预算区间 对应划分，根据节点度数的 比例分布，将其 映射到指数分布的分位数区间，从中 采样出个性化的隐私预算。\n拓扑重要性个性化，总隐私预算以区间 Lei D, Song Z, Yuan Y, et al. Achieving Personalized Privacy-Preserving Graph Neural Network via Topology Awareness[C]//Proceedings of the ACM on Web Conference 2025. 2025: 3552-3560.\n提出“邻接信息熵”（Adjacency Information Entropy, AIE）来衡量节点拓扑重要性，既考虑直连邻居也考虑间接关系：先算邻接度 $AD_u=\\sum_{v\\in \\mathcal N_u} D_v$，再定义概率 $p_u=D_u/AD_v$，最后得信息熵式的 $AIE_u=-\\sum_{v\\in \\mathcal N_u}(p_u\\log_2 p_u),p_v$（式(4)–(6)）。重要性越高→隐私敏感度越高。\n将总预算区间 $[,\\epsilon_b,\\epsilon_e,]$ 按节点隐私敏感度分成 $M$ 个等级与对应子区间，并假设预算在该区间内服从指数分布（真实网络度分布常呈幂律，少数节点很重要）。通过指数分布分位点把 $[,\\epsilon_b,\\epsilon_e,]$ 切成 $(\\epsilon_b,\\epsilon_1],(\\epsilon_1,\\epsilon_2],\\dots,(\\epsilon_{M-2},\\epsilon_e]$，切分边界用式(7)(8)的分位数关系确定；重要节点→分到更小的 $\\epsilon$（更强保护/更大噪声），不太重要的节点→更大的 $\\epsilon$（更少噪声）。每个节点最终从其子区间随机采样得到个性化预算 $\\epsilon_i$。\n各节点用自己的 $\\epsilon_i$ 做拉普拉斯机制：$\\hat X_i=f(X_i)+\\mathrm{Lap}(\\Delta f/\\epsilon_i)$（式(3)、(9)），并用随机响应扰动标签（式(12)），实现特征+标签双重保护。\n因不同邻居被加的噪声强度不同，直接平均会放大高噪声邻居的负面影响。论文据“越重要→预算越小→噪声越大”的链条，给重要邻居更小权重： $$ W_{u,v}=1+\\frac{1}{D_u}-\\frac{AIE_v}{\\sum_{i\\in Ner_u}AIE_{u,i}+AIE_u}, $$ 再做加权聚合（式(10)(11)）。这样能抑制差异化DP噪声对表示学习的影响。\nTDP-GNN 通过拓扑结构识别节点重要性，划分为多个隐私敏感度等级，映射到指数分布的预算区间并采样个性化预算，再结合加权聚合抑制噪声。\n上下文多臂赌博机（CMAB）算法分配（区间） Zhang X, Zhou Y, Hu M, et al. BGTplanner: Maximizing Training Accuracy for Differentially Private Federated Recommenders via Strategic Privacy Budget Allocation[J]. IEEE Transactions on Services Computing, 2025.\n步骤 1：生成奖励的预测\n对于每个动作 $a_t$ 和上下文 $X_t$，BGTplanner使用高斯过程回归模型预测奖励 $r_t$： $$ \\mu(z_t) = \\text{GPR}(a_t, X_t) $$ 步骤 2：计算动作的评分\n根据预测的奖励 $\\mu(z_t)$，为每个可能的动作（隐私预算分配方案）计算一个评分 $\\beta_t(a)$，公式如下： $$ \\beta_t(a) = \\mu(z_t) - \\langle \\epsilon_{\\text{total}} - \\epsilon_t, \\lambda_t \\rangle $$​\t其中，$\\lambda_t$ 是用于长期隐私预算约束的拉格朗日乘子，确保在整个训练过程中不会超出总预算。\n步骤 3：选择最优的隐私预算分配方案 $\\gamma$ 是探索和利用的权衡参数，控制着系统是否偏向于选择当前最优的动作（利用）或探索其他可能的动作。 $A$ 是动作空间的大小，表示可能的隐私预算分配方案的数量。 步骤 4：更新隐私预算消耗 在每轮训练之后，BGTplanner通过隐私预算消耗函数来计算实际消耗的隐私预算 $\\epsilon_t$，并更新剩余预算。 假设我们有如下参数：\n总隐私预算 $\\epsilon_{\\text{total}} = 10$ 隐私预算区间：$\\epsilon_{\\text{min}} = 1, \\epsilon_{\\text{max}} = 5$ 每轮的隐私预算分配动作是从区间 $[1, 5]$ 中选择的。 在某个训练回合中，BGTplanner预测奖励为：\n$$ \\mu(z_t) = 0.8 \\quad (\\text{基于历史信息和上下文的奖励预测}) $$ 接着，BGTplanner计算所有可能动作的评分，并选择评分最高的动作。例如，假设动作 $a_1$ 得分为 0.9，动作 $a_2$ 得分为 0.7，最终选择 $a_1$ 作为隐私预算分配方案。\nBGTplanner 每轮都用 CMAB 从一组预算选项中，智能选一个最合适的隐私预算来用\n探讨隐私预算的推荐值 Du W, Ma X, Dong W, et al. Calibrating privacy budgets for locally private graph neural networks[C]//2021 International Conference on Networking and Network Applications (NaNA). IEEE, 2021: 23-29.\n采用了 Multi-bit LDP Mechanism (LPGNN的方法)对用户特征进行扰动:\n输入：\n用户特征向量$ x∈[α,β]^d$ 隐私预算$\\epsilon$ 控制参数 m（每次扰动的特征维度数） 输出：\n扰动后的特征向量 $ x∈{-1,0,1}^d$ 通过链路预测准确率和加入属性推断攻击后的F1-score值推荐隐私预算值\n项目 内容 目标 在 LDP 保护的 GNN 中合理选择隐私预算 ε 方法 利用属性推断攻击效果作为隐私度量，结合链路预测准确率评估效用 隐私机制 Multi-bit LDP 机制，用户本地扰动特征，服务器无偏重构 推荐 ε 值 0.5 ~ 1（视具体业务对隐私和效用的需求） 基于遗传算法（GA）的隐私预算分配 Li Y, Song X, Tu Y, et al. GAPBAS: Genetic algorithm-based privacy budget allocation strategy in differential privacy K-means clustering algorithm[J]. Computers \u0026amp; Security, 2024, 139: 103697.\n通过分析噪声对质心的影响，推导出 最小隐私预算$ε_m$： $$ ε_m=(\\frac{200k^3d+(1+d)^2}{N^2}(1+ρ^2))^{1/2} $$ 其中：\nk：聚类数；d：数据维度；N：样本数量；ρ：噪声相关系数（通常取 0.225）； 每轮预算必须满足：$ε_t$≥$ε_m$，否则噪声过大导致质心不收敛。\n每个个体是一个长度为 $T$ 的浮点数组：${ε_1,ε_2,\u0026hellip;,ε_T}$ GAPBAS 将每轮隐私预算组合成序列，作为遗传算法的个体，在满足总预算和最小预算约束下，优化出使聚类效果（NICV）最优的预算分配策略。\n基于隐私安全等级（Privacy Security Level, PSL） Shen Z, He S, Wang H, et al. A differential privacy budget allocation method combining privacy security level[J]. Journal of Communications and Information Networks, 2023, 8(1): 90-98.\n提出 PSL 方法：为每个位置分配一个“隐私安全等级”，并据此动态分配隐私预算 $ε$，实现 个性化、拓扑感知的隐私保护。\n步骤：\n使用 P-series（p-级数） 为初始敏感位置分配隐私预算\n使用 P-series 为初始敏感位置分配预算： $$ \\varepsilon_{m} = \\frac{\\varepsilon}{\\zeta(p)} \\times \\frac{1}{m^{p}}, \\quad m \\in \\mathbb{N}^{+}, \\quad p \u003e 1 $$ $\\varepsilon$：总隐私预算； $\\zeta(p)$：P级数收敛值（如 p=2 时，$\\zeta(2)= π²/6$； m：敏感位置编号（按重要性排序）； 结果：重要位置（m 小）获得更大预算（更小噪声） 根据 距离与节点度 为敏感点的邻居分配预算，并支持 动态时间调整\nPSL定义： $$ \\mathrm{PSL}(k_{m}) = \\lambda \\times \\varepsilon_{m} = \\lambda \\times \\frac{\\varepsilon}{\\zeta(p)} \\times m^{p} $$ PSL 与预算$\\varepsilon$ 成反比； $\\lambda$ 为调节参数; 用于衡量位置的“隐私敏感度”。 将 PSL 映射为隐私预算$ε$，满足 $\\epsilon × PSL = \\gamma$（$\\gamma$ 为常数）\n假设：\n敏感节点 $k_1$ 的 PSL = 0.6079； 邻居 A 距离为 1，邻居 B 距离为 2； NPS = {A, B}； 则： $$ \\mathrm{PSL}_{A} = \\frac{1/1}{(1/1 + 1/2)} \\times 0.6079 = 0.4053, \\\\ \\mathrm{PSL}_{B} = \\frac{1/2}{(1/1 + 1/2)} \\times 0.6079 = 0.2026 $$ 再映射回预算： $$ \\epsilon_{A} = \\frac{\\gamma}{\\mathrm{PSL}_{A}} = \\frac{0.5}{0.4053} \\approx 1.23 , \\\\ \\epsilon_{B} = \\frac{\\gamma}{\\mathrm{PSL}_{B}} = \\frac{0.5}{0.2026} \\approx 2.47 $$ PSL 方法通过 P-series 为敏感位置分配递减预算，再结合距离与节点度为邻居分配个性化预算，并支持时间动态调整，实现“重要位置多留数据，敏感位置多加噪声”的精细化隐私保护。\n","date":"2025-10-23T19:00:59+08:00","permalink":"https://bobqaq003.github.io/Kuka-hugo/p/privacy%E8%87%AA%E9%80%82%E5%BA%94%E9%9A%90%E7%A7%81%E9%A2%84%E7%AE%97%E5%88%86%E9%85%8D/","title":"【Privacy】自适应隐私预算分配"}]